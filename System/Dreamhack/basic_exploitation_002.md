## 📍basic_exploitation_002

```
이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_002)의 바이너리와 소스 코드가 주어집니다.  
프로그램의 취약점을 찾고 익스플로잇해 셸을 획득한 후, "flag" 파일을 읽으세요.  
"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.  
플래그의 형식은 DH{...} 입니다.
```

```
Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8048000)
```


### 소스코드

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void get_shell() {
    system("/bin/sh");
}

int main(int argc, char *argv[]) {
    char buf[0x80];
    initialize();
	
    read(0, buf, 0x80);
    printf(buf);
	
    exit(0);
}
```

![](Attachments/FCCB89F5-EA11-41A6-AF43-8A8ED5EAF528.png)


### 취약점

#### 포맷 스트링 취약점

```c
printf(buf);
```

`printf` 함수에 `buf`를 인자로 전달할 때, `printf("%s", buf)`처럼 형식 지정자를 사용하지 않고, 사용자 입력을 직접 포맷 문자열로 사용하고 있다.

이를 통해 사용자가 포맷 지정자(`%x`, `%s`, `%n` 등)를 입력으로 제공하여 메모리 내용을 읽거나 쓰는 등의 작업을 할 수 있다. 이로 인해 다음과 같은 공격이 가능하다:
- **메모리 덤프**: `%x` 또는 `%s`를 사용하여 메모리의 내용을 출력
- **메모리 쓰기**: `%n`을 사용하여 특정 메모리 주소에 값을 기록
- **ROP 공격**: 포맷 문자열을 통해 메모리의 특정 위치를 조작하여 함수의 리턴 주소 등을 변경하여 악성 코드를 실행

